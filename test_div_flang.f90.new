module norm_mod
implicit none
private
public :: norm

contains

function is_posinf(x) result(res)
use, intrinsic :: iso_fortran_env, only : RP => real32
implicit none
real(RP), intent(in) :: x
logical :: res
res = (x > HUGE(x))
end function is_posinf

function norm(x, p) result(y)
!--------------------------------------------------------------------------------------------------!
! This function calculates the P-norm of a vector X.
!--------------------------------------------------------------------------------------------------!
use, intrinsic :: iso_fortran_env, only : RP => real32
use, intrinsic :: ieee_arithmetic, only : is_nan => ieee_is_nan, is_finite => ieee_is_finite
implicit none

! Inputs
real(RP), intent(in) :: x(:)
real(RP), intent(in), optional :: p
! Outputs
real(RP) :: y
! Local variables
real(RP), parameter :: ONE = 1.0_RP, TWO = 2.0_RP, ZERO = 0.0_RP
real(RP) :: maxabs
real(RP) :: p_loc
real(RP) :: scaling
real(RP) :: scalmax
real(RP) :: scalmin

!====================!
! Calculation starts !
!====================!

if (present(p)) then
    p_loc = p
else
    p_loc = TWO
end if

! If SIZE(X) = 0, then MAXVAL(ABS(X)) = -HUGE(X); since we handle such a case individually,
! it is OK to write MAXVAL(ABS(X)) below, but we append 0 for robustness.
maxabs = maxval([abs(x), ZERO])
! To avoid over/underflow, we scale X by SCALING defined as follows when it is necessary.
! We make sure SCALMIN >= MAX(REALMIN, 1/REALMAX) and SCALMAX <= MIN(REALMAX, 1/REALMIN).
! Given a numeric model for floating-point numbers,
! REALMIN = TINY(ZERO) = 2^{emin-1} and REALMAX = HUGE(ZERO) = (1 - b^{-p}) * b^{emax} >= b^{emax-1},
! where b = RADIX(ZERO) >= 2 is the base, p = DIGITS(ZERO) >= 1 is the number of significant digits
! in base b, and emin = MINEXPONENT(ZERO), emax = MAXEXPONENT(ZERO) are the min, max exponents.
! N.B.: IEEE 754 specifies emax and requires that emin = 1 - emax for the "Binary interchange
! floating-point formats" binary32, binary64, and binary128 (see Sec. 3.3 of IEEE Std 754-2019).
! However, the mathematical definition of [emin, emax] in Fortran standards indeed corresponds to
! that of [emin + 1, emax + 1] in IEEE 754. In addition, Fortran compilers may not implement REAL32,
! REAL64, and REAL128 corresponding to binary32, binary64, and binary128. For instance,
! nagfor 7 has p = 106, emin = -968 and emax = 1023 for REAL128, while
! IEEE 754 has p = 113, emin = -16382, and emax = 16383 for binary128.
scalmin = real(radix(ZERO), RP)**max(minexponent(ZERO) - 1, 1 - maxexponent(ZERO))
scalmax = real(radix(ZERO), RP)**min(maxexponent(ZERO) - 1, 1 - minexponent(ZERO))
scaling = min(max(maxabs, scalmin), scalmax)

print * , "maxabs = ", maxabs, "scalmin = ", scalmin , "scalmax = ", scalmax, "scaling = ", scaling
print * , 'x = ', x
print * , 'x/scaling = ', x/scaling

if (size(x) == 0) then
    y = ZERO
elseif (p_loc <= 0) then
    y = real(count(abs(x) > 0), kind(y))
elseif (.not. all(is_finite(x))) then
    ! If X contains NaN, then Y is NaN. Otherwise, Y is Inf when X contains +/-Inf.
    y = sum(abs(x))
elseif (maxabs <= 0) then
    y = ZERO
else
    if (is_posinf(p_loc)) then
        y = maxabs
    elseif (.not. present(p) .or. abs(p_loc - TWO) <= 0) then
        ! N.B.: We may use the intrinsic NORM2. Here, we use the following naive implementation to
        ! get full control on the computation in a way similar to MATPROD and INPROD.
        y = sqrt(sum(x**2))
        ! The following code handles over/underflow naively.
        if ((is_posinf(y) .and. is_finite(maxabs)) .or. (y <= 0 .and. maxabs > 0)) then
            y = scaling * sqrt(sum((x / scaling)**2))
        end if
    else
        y = sum(abs(x)**p_loc)**(ONE / p_loc)
        if ((is_posinf(y) .and. is_finite(maxabs)) .or. (y <= 0 .and. maxabs > 0)) then
            y = scaling * sum(abs(x / scaling)**p_loc)**(ONE / p_loc)
        end if
    end if
end if

!====================!
!  Calculation ends  !
!====================!

end function norm

end module norm_mod

! test_div_flang.f90
program test_div_flang
use iso_fortran_env, only : RP => REAL32
use norm_mod, only : norm

implicit none

! The code may behave differently depending on the dimension of the array. Try them.
real(RP) :: a(14), b(14), c
real(RP) :: scaling
real(RP) :: scalmax
real(RP) :: scalmin
real(RP), parameter :: ONE = 1.0_RP, TWO = 2.0_RP, ZERO = 0.0_RP
a =  [0., 0., 7.E-45, 7.E-45, 0., 5.E-45, 0., 5.E-45, 5.E-45, 0., 0., 0., 0., 5.E-45]

!real(RP) :: a(9), b(9), c
!a =  [5.E-45, 0., 5.E-45, 5.E-45, 0., 0., 0., 0., 5.E-45]
!
!real(RP) :: a(8), b(8), c
!a =  [0., 5.E-45, 5.E-45, 0., 0., 0., 0., 5.E-45]

b =  a / maxval(abs(a))
c =  maxval(abs(a))

print *,  '>>> Dimension = ', size(a)

print *, a/maxval(abs(a)), '|', b
print *, (a/maxval(abs(a)))**2, '|', b**2
print * , '------------------'
print *, a, '|', a/maxval(abs(a)), '|', b
print *, a, '|', (a/maxval(abs(a)))**2, '|', b**2

print * , '=================='

print *, a/c, '|', b
print *, (a/c)**2, '|', b**2
print * , '------------------'
print *, a, '|', a/c, '|', b
print *, a, '|', (a/c)**2, '|', b**2

scalmin = real(radix(ZERO), RP)**max(minexponent(ZERO) - 1, 1 - maxexponent(ZERO))
scalmax = real(radix(ZERO), RP)**min(maxexponent(ZERO) - 1, 1 - minexponent(ZERO))
c = min(max(c, scalmin), scalmax)
print * , '=================='

print *, a/c, '|', b
print *, (a/c)**2, '|', b**2

print * , tiny(c), '|', a/c, '|', a/tiny(c)

c =  norm(a)
print * , 'norm(a) = ', c

end program test_div_flang
